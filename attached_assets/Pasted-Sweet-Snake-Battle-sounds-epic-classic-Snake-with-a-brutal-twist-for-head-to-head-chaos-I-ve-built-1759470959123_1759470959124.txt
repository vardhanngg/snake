Sweet! Snake Battle sounds epic‚Äîclassic Snake with a brutal twist for head-to-head chaos. I've built a minimal playable prototype based on your specs. It's online 2-player via Socket.IO, so you and your friend can battle from different computers/browsers. Snakes grow by eating food, and the special attack lets you "slash" the opponent's tail if you're close enough (activated by spacebar). Twists include random speed boosts (eat to go faster temporarily) and traps (static walls that kill on hit).
This is simplified for quick setup: grid-based movement (no smooth curves yet), basic collisions, and real-time sync. Rounds end when one snake hits length 50 (win) or dies (lose). Best of 3? Just restart the room.
Setup Instructions

Install Node.js (nodejs.org if needed).
Create a folder (e.g., snake-battle).
Inside: Create server.js and a public subfolder with index.html in it.
Terminal in folder:
textnpm init -y
npm install express socket.io

Paste the code below.
Run node server.js.
Open http://localhost:3000 in two browsers (or share IP for different machines).
Enter same room code (e.g., "battle123"), hit "Join"‚Äîgame starts!

Host on Glitch/Replit for easy online sharing.
server.js
javascriptconst express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

app.use(express.static('public'));

const rooms = {}; // { roomId: { player1: socket.id, player2: socket.id, gameState: {...} } }

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  socket.on('join-room', (roomId) => {
    if (!rooms[roomId]) {
      rooms[roomId] = { player1: null, player2: null, gameState: initGameState() };
    }
    if (!rooms[roomId].player1) {
      rooms[roomId].player1 = socket.id;
    } else if (!rooms[roomId].player2) {
      rooms[roomId].player2 = socket.id;
      // Start game
      io.to(roomId).emit('start-game', rooms[roomId].gameState);
      setInterval(() => updateGame(roomId), 200); // Game tick
    }
    socket.join(roomId);
    socket.roomId = roomId;
    socket.playerId = rooms[roomId].player1 === socket.id ? 'p1' : 'p2';
  });

  socket.on('move', (data) => {
    const room = rooms[data.roomId];
    if (room && room.gameState) {
      const player = socket.playerId === 'p1' ? room.gameState.snake1 : room.gameState.snake2;
      player.direction = data.direction;
    }
  });

  socket.on('attack', (data) => {
    const room = rooms[data.roomId];
    if (room && room.gameState) {
      const attacker = socket.playerId === 'p1' ? room.gameState.snake1 : room.gameState.snake2;
      const victim = socket.playerId === 'p1' ? room.gameState.snake2 : room.gameState.snake1;
      if (Math.abs(attacker.head.x - victim.head.x) <= 1 && Math.abs(attacker.head.y - victim.head.y) <= 1) {
        // Slash: remove 3 segments from victim
        victim.body.splice(-3, 3);
        if (victim.body.length < 1) {
          endGame(data.roomId, socket.playerId === 'p1' ? 'p2' : 'p1');
        }
      }
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

function initGameState() {
  return {
    snake1: { body: [{x: 5, y: 10}], direction: {x: 1, y: 0}, length: 1, speedBoost: 0, color: 'green' },
    snake2: { body: [{x: 15, y: 10}], direction: {x: -1, y: 0}, length: 1, speedBoost: 0, color: 'red' },
    food: {x: Math.floor(Math.random() * 20), y: Math.floor(Math.random() * 20)},
    powerUps: [], // e.g., {x, y, type: 'speed' or 'trap'}
    traps: [{x: 2, y: 2}, {x: 18, y: 18}], // Static traps
    gridSize: 20,
    winLength: 50
  };
}

function updateGame(roomId) {
  const room = rooms[roomId];
  if (!room || !room.gameState) return;
  const state = room.gameState;

  // Move snake1
  moveSnake(state.snake1, state);
  // Move snake2
  moveSnake(state.snake2, state);

  // Check food eat
  if (state.snake1.head.x === state.food.x && state.snake1.head.y === state.food.y) {
    state.snake1.length++;
    state.food = {x: Math.floor(Math.random() * state.gridSize), y: Math.floor(Math.random() * state.gridSize)};
    if (Math.random() < 0.3) state.powerUps.push({x: state.food.x, y: state.food.y, type: 'speed'});
  }
  if (state.snake2.head.x === state.food.x && state.snake2.head.y === state.food.y) {
    state.snake2.length++;
    state.food = {x: Math.floor(Math.random() * state.gridSize), y: Math.floor(Math.random() * state.gridSize)};
    if (Math.random() < 0.3) state.powerUps.push({x: state.food.x, y: state.food.y, type: 'speed'});
  }

  // Power-ups (simple: eat for speed boost)
  state.powerUps = state.powerUps.filter(pu => {
    if (state.snake1.head.x === pu.x && state.snake1.head.y === pu.y) {
      state.snake1.speedBoost = 500; // ms boost
      return false;
    }
    if (state.snake2.head.x === pu.x && state.snake2.head.y === pu.y) {
      state.snake2.speedBoost = 500;
      return false;
    }
    return true;
  });

  // Decay speed boost
  if (state.snake1.speedBoost > 0) state.snake1.speedBoost -= 200;
  if (state.snake2.speedBoost > 0) state.snake2.speedBoost -= 200;

  // Check wins/losses
  if (state.snake1.length >= state.winLength) endGame(roomId, 'p1');
  if (state.snake2.length >= state.winLength) endGame(roomId, 'p2');
  if (state.snake1.body.length < 1) endGame(roomId, 'p2');
  if (state.snake2.body.length < 1) endGame(roomId, 'p1');

  io.to(roomId).emit('game-update', state);
}

function moveSnake(snake, state) {
  const head = {x: snake.body[0].x + snake.direction.x, y: snake.body[0].y + snake.direction.y};
  snake.body.unshift(head);
  snake.head = head;

  // Trap collision
  if (state.traps.some(t => t.x === head.x && t.y === head.y)) {
    snake.body = []; // Die
    return;
  }

  // Wall collision
  if (head.x < 0 || head.x >= state.gridSize || head.y < 0 || head.y >= state.gridSize) {
    snake.body = [];
    return;
  }

  // Self collision
  if (snake.body.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) {
    snake.body = [];
    return;
  }

  // Opponent collision (push back / damage)
  const otherSnake = snake === state.snake1 ? state.snake2 : state.snake1;
  if (otherSnake.body.some(seg => seg.x === head.x && seg.y === head.y)) {
    otherSnake.body.splice(-2, 2); // Cut tail
    if (otherSnake.body.length < 1) return;
  }

  // Trim tail if not growing
  if (snake.body.length > snake.length) {
    snake.body.pop();
  }
}

function endGame(roomId, winner) {
  io.to(roomId).emit('game-over', { winner });
  // Reset for next round? For now, just emit
}

server.listen(3000, () => {
  console.log('Server on http://localhost:3000');
});
public/index.html
html<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Battle</title>
  <style>
    body { margin: 0; padding: 20px; background: #111; color: #fff; font-family: Arial; display: flex; flex-direction: column; align-items: center; }
    #join { text-align: center; }
    #roomInput { padding: 10px; font-size: 16px; margin-right: 10px; }
    button { padding: 10px 20px; font-size: 16px; background: #ff6600; color: white; border: none; cursor: pointer; }
    button:hover { background: #e55a00; }
    #game { display: none; text-align: center; }
    canvas { border: 2px solid #333; background: #000; }
    #info { font-size: 18px; margin: 10px; }
    #winMsg { font-size: 32px; color: #4CAF50; margin: 20px; }
  </style>
</head>
<body>
  <div id="join">
    <h1>Snake Battle</h1>
    <input id="roomInput" type="text" placeholder="Room code (e.g., battle123)">
    <button onclick="joinRoom()">Join</button>
    <p><small>Player 1: Arrow keys. Player 2: WASD. Spacebar: Attack!</small></p>
  </div>
  <div id="game">
    <div id="info">Your length: <span id="length">1</span> | Food at random spots. Eat power-ups for speed!</div>
    <canvas id="canvas" width="400" height="400"></canvas>
    <div id="winMsg"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 20;
    const cellSize = 20;
    let gameState = null;
    let mySnake = null;
    let keys = {};

    function joinRoom() {
      const roomId = document.getElementById('roomInput').value.trim();
      if (roomId) socket.emit('join-room', roomId);
    }

    socket.on('start-game', (state) => {
      document.getElementById('join').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      gameState = state;
      mySnake = socket.playerId === 'p1' ? state.snake1 : state.snake2;
      document.addEventListener('keydown', handleKey);
    });

    socket.on('game-update', (state) => {
      gameState = state;
      mySnake = socket.playerId === 'p1' ? state.snake1 : state.snake2;
      document.getElementById('length').textContent = mySnake.length;
      draw();
    });

    socket.on('game-over', (data) => {
      const winMsg = data.winner === socket.playerId ? 'You Win!' : 'You Lose!';
      document.getElementById('winMsg').textContent = winMsg;
    });

    function handleKey(e) {
      if (e.code === 'Space') {
        e.preventDefault();
        socket.emit('attack', { roomId: socket.roomId });
        return;
      }
      let dir;
      if (socket.playerId === 'p1') {
        if (e.code === 'ArrowUp') dir = {x: 0, y: -1};
        if (e.code === 'ArrowDown') dir = {x: 0, y: 1};
        if (e.code === 'ArrowLeft') dir = {x: -1, y: 0};
        if (e.code === 'ArrowRight') dir = {x: 1, y: 0};
      } else {
        if (e.code === 'KeyW') dir = {x: 0, y: -1};
        if (e.code === 'KeyS') dir = {x: 0, y: 1};
        if (e.code === 'KeyA') dir = {x: -1, y: 0};
        if (e.code === 'KeyD') dir = {x: 1, y: 0};
      }
      if (dir && (dir.x !== -mySnake.direction.x || dir.y !== -mySnake.direction.y)) {
        socket.emit('move', { roomId: socket.roomId, direction: dir });
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = '#333';
      for (let i = 0; i <= gridSize; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.stroke();
      }

      // Traps (red squares)
      ctx.fillStyle = '#ff0000';
      gameState.traps.forEach(t => {
        ctx.fillRect(t.x * cellSize, t.y * cellSize, cellSize, cellSize);
      });

      // Food (yellow)
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(gameState.food.x * cellSize, gameState.food.y * cellSize, cellSize, cellSize);

      // Power-ups (blue)
      ctx.fillStyle = '#0000ff';
      gameState.powerUps.forEach(pu => {
        ctx.fillRect(pu.x * cellSize, pu.y * cellSize, cellSize, cellSize);
      });

      // Snakes
      drawSnake(gameState.snake1, '#00ff00');
      drawSnake(gameState.snake2, '#ff0000');
    }

    function drawSnake(snake, color) {
      ctx.fillStyle = color;
      snake.body.forEach((seg, i) => {
        ctx.fillRect(seg.x * cellSize + 1, seg.y * cellSize + 1, cellSize - 2, cellSize - 2);
        if (i === 0) { // Head
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(seg.x * cellSize + 5, seg.y * cellSize + 5, 10, 10);
          ctx.fillStyle = color;
        }
      });
    }
  </script>
</body>
</html>
How to Play

Controls: P1: Arrows to move, Space to attack (slash nearby foe). P2: WASD + Space.
Eat yellow food to grow (reach 50 length to win!).
Blue power-ups give speed bursts.
Red traps are deadly‚Äîavoid 'em!
Bump opponent to cut their tail; get too close and spacebar for a slash (removes 3 segments).
If you hit walls/traps/self/opponent too hard, you shrink or die‚Äîlast snake standing wins.
Arena is 20x20; trails aren't blocking yet (easy mode for proto), but collisions hurt.

Test it‚Äîshould sync moves/attacks in real-time. Bugs? Like snakes overlapping funny? Let me know. Upgrades: Add bombs (exploding on eat), more traps, smoother graphics, or AI for single-player practice? Your move! üêç‚öîÔ∏è